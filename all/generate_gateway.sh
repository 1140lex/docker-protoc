#!/bin/bash

set -e

HTTP_PORT=8080

printUsage() {
	echo "Generates a docker image of a grpc-gateway server for a given service proto."	
  echo
  echo "The container will listen on port ${HTTP_PORT} for HTTP traffic, and proxy requests"
  echo "to the gRPC service. In addition, it will serve a Swagger definition of its API at"
  echo "/swagger.json"
  echo
  echo "Usage: generate_gateway.sh -f <service.proto> -p service_package -s ServiceName"
  echo
  echo "Options:"
  echo "-h, --help                 Show this message."
  echo "-f, --file FILE            The proto file to generate a gateway for."
  echo "-s, --service SERVICE      The name of the gRPC service."
  echo "-a, --address ADDRESS      The DNS address of the gRPC service."
  echo "-p, --port PORT            The port the gRPC service is listening on."
  echo "-c, --container CONTAINER  The name of the docker container to generate."
  echo "-i EXTRA_INCLUDES                Extra proto includes."
}

#### PARSE ARGUMENTS ####
# Path to the proto file.
FILE=""
# Name of the service
SERVICE=""
# Name of the container
CONTAINER=""
# Address of the gRPC service
GRPC_SERVICE_HOST=""
GRPC_SERVICE_PORT=""
# Extra proto includes
EXTRA_INCLUDES=""

while test $# -gt 0; do
	case "$1" in
		-h|--help)
			printUsage
			exit 0
			;;
		-f|--file)
			shift
			if test $# -gt 0; then
				FILE=$1
			else
				printUsage
				exit 1
			fi
			shift
			;;
		-s|--service)
			shift
			if test $# -gt 0; then
				SERVICE=$1
			else
				printUsage
				exit 1
			fi
			shift
			;;
		-c|--container)
			shift
			if test $# -gt 0; then
				CONTAINER=$1
			else
				printUsage
				exit 1
			fi
			shift
			;;
		-a|--address)
			shift
			if test $# -gt 0; then
				GRPC_SERVICE_HOST=$1
			else
				printUsage
				exit 1
			fi
			shift
			;;
    -p|--port)
			shift
			if test $# -gt 0; then
        GRPC_SERVICE_PORT=$1
			else
				printUsage
				exit 1
			fi
			shift
			;;
    -i)
			if test $# -gt 0; then
        EXTRA_INCLUDES=$1
			else
				printUsage
				exit 1
			fi
			shift
			;;
		*)
			printUsage
			exit 1
			;;
	esac
done

#### VALIDATE INPUT ####
if [[ -z $FILE ]]; then
    echo "Error: You must specify the proto file name"
    printUsage
    exit 1
fi

if [[ -z $SERVICE ]]; then
    echo "Error: You must specify the proto service name"
    printUsage
    exit 1
fi

if [[ -z $CONTAINER ]]; then
    echo "Error: You must specify the Docker container name"
    printUsage
    exit 1
fi

if [[ -z $GRPC_SERVICE_HOST ]]; then
    echo "Error: You must specify the hostname of the gRPC service to proxy."
    printUsage
    exit 1
fi

if [[ -z $GRPC_SERVICE_PORT ]]; then
    echo "Error: You must specify the port of the gRPC service to proxy."
    printUsage
    exit 1
fi

#### BUILD GATEWAY PROJECT ####
TMPDIR=`mktemp -d /tmp/grpc-gateway.XXXXXXXXXX`
echo "Creating template project in $TMPDIR."

echo "Generating Dockerfile."
cat << DOCKERFILE >> $TMPDIR/Dockerfile
FROM golang:1.9.2-alpine3.6 AS build
RUN apk --update upgrade
RUN apk add git make

WORKDIR /go
ADD . /go
RUN go get ./...
RUN go build -o grpc_gateway src/pkg/main/main.go

FROM alpine:3.6
WORKDIR /app
COPY --from=build /go/grpc_gateway /app/
COPY --from=build /go/config.yaml /app/
COPY --from=build /go/src/gen/pb-go/proto/${SERVICE}.swagger.json /app/

ENTRYPOINT /app/grpc_gateway
DOCKERFILE

echo "Generating protobuf files"
mkdir -p $TMPDIR/src/proto/
cp $FILE $TMPDIR/src/proto/

INCLUDES_ARG=""
if [[ ! -z "$EXTRA_INCLUDES" ]]; then
  INCLUDES_ARG="-i $EXTRA_INCLUDES"
fi
docker run -v $TMPDIR/src:/defs namely/protoc-all -f proto/`basename $FILE` -l go --with-gateway $INCLUDES_ARG

echo "Generating entry-point code."
mkdir -p $TMPDIR/src/pkg/main/

cat << ENTRYPOINT >> $TMPDIR/src/pkg/main/main.go
// AUTOMATICALLY GENERATED BY namely/docker-protoc
// DO NOT EDIT. DO NOT CHECK INTO GITHUB. DO NOT PASS GO. DO NOT COLLECT \$200.
package main

import (
	"fmt"
	"log"
	"net/http"
  "os"
  "os/signal"
  "strings"
	"time"

	"github.com/grpc-ecosystem/grpc-gateway/runtime"
  "github.com/spf13/viper"
	"golang.org/x/net/context"
	"google.golang.org/grpc"

	gw "gen/pb-go/proto"
)

type proxyConfig struct {
	host    string
	port    int
	swagger string
}

func SetupMux(ctx context.Context, cfg proxyConfig) *http.ServeMux {
	mux := http.NewServeMux()

	mux.HandleFunc("/swagger.json", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, cfg.swagger)
	})

	opts := []grpc.DialOption{grpc.WithInsecure()}
	gwmux := runtime.NewServeMux()
	endpoint := fmt.Sprintf("%v:%v", cfg.host, cfg.port)
	err := gw.Register${SERVICE}HandlerFromEndpoint(ctx, gwmux, endpoint, opts)
	if err != nil {
		log.Fatalf("Could not register gateway: %v", err)
	}
	mux.Handle("/", gwmux)

	return mux
}

// SetupViper returns a viper configuration object
func SetupViper() *viper.Viper {
  viper.SetConfigName("config")
  viper.AddConfigPath(".")
  viper.SetEnvPrefix("${SERVICE}")
  viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
  viper.AutomaticEnv()

  err := viper.ReadInConfig()
  if err != nil {
    log.Fatalf("Could not read config: %v", err)
  }

  return viper.GetViper()
}

// SignalRunner runs a runner function until an interrupt signal is received, at which point it
// will call stopper.
func SignalRunner(runner, stopper func()) {
  signals := make(chan os.Signal, 1)
  signal.Notify(signals, os.Interrupt, os.Kill)

  go func() {
    runner()
  }()

  fmt.Println("hit Ctrl-C to shutdown")
  select {
  case <-signals:
    stopper()
  }
}

func main() {

	cfg := SetupViper()
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	mux := SetupMux(ctx, proxyConfig{
		host:    cfg.GetString("grpc_service_host"),
		port:    cfg.GetInt("grpc_service_port"),
		swagger: cfg.GetString("swagger.file"),
	})

	addr := fmt.Sprintf(":%v", cfg.GetInt("proxy.port"))
	server := &http.Server{Addr: addr, Handler: mux}

	SignalRunner(
		func() {
			fmt.Printf("launching http server on %v\n", server.Addr)
			if err := server.ListenAndServe(); err != nil {
				log.Fatalf("Could not start http server: %v", err)
			}
		},
		func() {
			shutdown, _ := context.WithTimeout(ctx, 10*time.Second)
			server.Shutdown(shutdown)
		})
}
ENTRYPOINT

cat << VIPER >> $TMPDIR/config.yaml
grpc_service_port: ${GRPC_SERVICE_PORT}
grpc_service_host: ${GRPC_SERVICE_HOST}
proxy.port: ${HTTP_PORT}
swagger.file: "${SERVICE}.swagger.json"
VIPER

echo "Building docker container $CONTAINER."
docker build -t $CONTAINER -f $TMPDIR/Dockerfile $TMPDIR

echo "Generation done."
rm -rf $TMPDIR
